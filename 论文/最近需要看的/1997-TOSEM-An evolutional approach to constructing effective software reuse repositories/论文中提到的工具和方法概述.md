# A MULTI-OBJECTIVE SEARCH BASED APPROACH TO IDENTIFY REUSABLE SOFTWARE COMPONENTS

>  基于组件的软件开发（CBSD）
>
> 基于组件的软件工程(CBSE)
>
> Reusable Software Component Identification (RSCI)
>
> Multi-Objective Evolutionary Optimization (MOEO)
>
>  Frequent Usage Pattern (FUP) based cohesion

**当前文章所做的东西**：本文提出了一种可扩展的多目标搜索方法，用于从软件系统的源代码中识别可复用的软件构件

对于面向对象软件范式，我们将组件视为一个单独的类或一组连接的类，这些类可以在最少修改的情况下重用。

为了识别这种关系，本文提出了三种关系：1)基于频繁使用模式的衔接；2)基于语义关联性的衔接；3)基于共变的耦合

**这篇论文中给出的组件的定义**：组件被认为是几个相互作用以提供特定系统功能的相关对象的集合。

文献中对软构件识别的研究分为两个层次：设计层和面向对象(OO)源代码层。

**对文中所提出的识别可重用组件方法有两种评估办法**

+ 一个众所周知的模块化指标，称为TurboMQ，用于评估原始系统的模块化和获得的组件。
+ 同时使用这三种关系的必要性通过制定总共六个不同的方案进一步证实了这一点。这些方案是通过将不同的关系视为个体、成对来设计的。最后，将这些公式化方案与所提出的方法（同时使用这三种关系）进行比较。

在文献中，已经提出了许多用于软件构件识别的方法，现有的RSCI技术依赖于测量由于方法调用、类型共享、用例、序列、类协作图和/或动态跟踪而产生的依赖关系。这些方法还使用各种集群技术和/或使用模型来执行分组和识别组件。然而，没有这样的方法侧重于基于系统中的成员变量使用(FUP)来度量依赖项。

作者认为，基于FUP的依赖关系对于可复用构件识别是必要的。

来自软件系统源代码的RSCI需要将底层体系结构分类为模块单元(也称为软件分配问题)。所谓底层体系结构，我们指的是软件的原始包结构，可重用软件组件将从该结构中识别出来。

本文首先利用从软件系统底层变更历史中获取的频繁使用模式(FUP)、语义关联度和共变关系三个参数来计算不同软件元素之间的内聚和耦合。FUP和语义关联度被用来衡量衔接强度，共变关系被用来衡量耦合强度。

# Extracting reusable components: A semi-automated approach for complex structures

> candidate component (CC)  候选组件CC
>
> Candidate Component Size (CCS)  候选组件尺寸（CCS）

我们提出了一个半自动的过程，指导软件工程师解开复杂的结构，以提取可复用的组件。该过程包括迭代分析，以识别和转换负责结构复杂性的类，并有效地减少候选组件的大小。

系统的结构被建模为有向图G=⟨V，E⟩，其中节点V和边E的集合分别表示类和它们之间的使用关系。使用关系包括类之间的所有类型的依赖关系，即继承、方法调用等。 



# A Survey For Effective Search And Retrieval Of Components From Software Repositories

> 主要还是在讲组件库的事情

PEEL extracts source code definitions of functions, constants,variables and macros from a source code file

**PEEL从源代码文件中提取函数、常量、变量和宏的源代码定义**

然后将这些信息提取并翻译成kandor对象.Kandor表示可以被视为一组包含组件信息的属性

# An Evolutionary Approach to Constructing Effective Software Reuse Repositories

PEEL（Parse and Extract Emacs Lisp）从文本文件中提取组件，并通过自动提取和交互式用户支持的组合对其进行索引。

PEEL使用三步程序处理术语：

+ 第一步是完全自动化的。术语摘自函数的名称以及定义之前的任何字符串或注释。将公共停止列表应用于提取的术语，以删除几乎没有语义含义的常见单词。
+ 第二步是向/户显示术语。用户可以删除术语、截断列表、在源代码窗口中高亮显示该术语，以显示该术语的使用方式和位置。
+ 第三步允许用户添加他们自己的术语，其中可以包括短语(用空格分隔的单词)和任何其他标点符号。

# **Mining Component Behavior to Support Software Retrieval**

> 这篇论文主要是描述的如何生成组件的描述
>
> 本文讨论(1)不基于自然语言文本的VON软件描述的自动生成和(2)依赖于(1)中开发的描述的软件检索。

> 组件检索中比较重要的是组件描述。在这个论文中他们开发出了自动描述可复用组件的方法。

## 组件库

从领域工程师的角度来看，组件库是存储库管理员放入生成的资产的地方。

从应用工程师的角度来看，组件库是他/她获取当前正在进行的开发的构建块的地方。

### 组件

组件的一般用途是将其集成到软件系统中。它是在领域工程过程(资产生成)或应用工程过程(软件开发)的实现阶段产生的资产的特殊形式(通用术语)。尽管术语组件通常与面向对象的范例(它很好地支持模块化系统的构建)直接相关，但组件不一定是对象。

#### 组件作为方法（功能）实体

+ 软件组件是具有良好定义和发布的接口的可执行软件的物理打包。
+ 软件组件是独立生产、获取和部署的二进制单位，相互作用形成一个功能系统的一部分。”此外，该定义强调可执行性、封闭性（至少通过作为二进制包使用）以及通过组件的接口的可访问性。
+ 关于组件的结构和功能的知识可以是可访问的，也可以是不可访问的，但是接口必须被明确地定义，其包括所提供的服务以及如何访问它们的完整列表、一般依赖关系或可能的错误条件。

#### 作为抽象载体的组件

组件(根据体系结构风格，组件的同义词是筛选器、对象、进程)被理解为通过连接器链接到其他组件的功能(域)实体

#### 作为可重复使用的构建块的组件

一个组件也应该有可能被其他程序员使用，只有当它的接口和环境依赖被很好地设计和记录时才可能是这种情况。



## 自动获取描述（Obtaining descriptions automatically）

#### 四维分类框架

可以根据软件过程、抽象、集成和可访问性四个方面对组件进行分类。

+ 过程：软件流程方面决定了组件可以在软件流程的哪个阶段使用。这从分析阶段到设计和实施阶段。请注意，Meyer不将测试用例视为组件，这从他的框架中排除了软件开发过程的后续阶段。此外，这个方面明确强调不是编程元素的组件！

+ 抽象：抽象水平根据其普遍性来描述该组件。考虑不同的观点，即功能抽象、相关元素组、数据抽象、框架或系统抽象。函数抽象是自包含功能的表示，由传统软件库中已知的子程序或函数表示。分组是一组收集的任意相关元素。数据抽象可以是命令式语言中的数据胶囊，也可以是面向对象语言中的类，涵盖数据实体。更高的抽象是通过框架实现的，这些框架必须根据一套规则使用。最高级别的抽象是通过使用粗粒度二进制组件实现的。由于面向对象技术的成熟度，它们可以在COM、CORBA或JavaBeans架构的基础上使用。

+ 集成：集成级别指的是组件集成到软件系统中的时间点。Meyer确定了三个不同的时间点：静态执行是指在编译时或链接时集成(它们在不重新编译的情况下是不可更改的)，可替换组件也在编译或链接时集成，但具有一定的动态可变性，以及动态组件，它们在系统执行时集成

+ 可访问性：可访问性级别来自开发人员可以使用组件的形式。在这里，可以识别三种不同的模式：通过接口描述进行交流，其中不能看到源代码。仅源代码访问，开发人员必须详细了解代码，以确定其功能。当通过接口提供访问权限时，还会提供信息隐藏信息，此外，源代码可用于检查、讨论和更正。分类模式的压缩视图见表2.1

	<img src="论文中提到的工具和方法概述.assets/image-20220706135431315.png" alt="image-20220706135431315" style="zoom:50%;" />

组件可以是函数、模块、对象或对象的簇；它们可能以源代码的形式出现，也可能以可执行状态出现。来自需求阶段或分析阶段的资产、测试文档和测试用例不被称为组件，因为这些产品不能被客户直接使用。组件是为系统提供重要功能的构建块。软件开发人员可以使用“真正的”组件来构建组件作者无法预见的新系统。这一目的再次将术语组件转移到重用领域。

# Extracting information from Python source code

[Extracting information from Python source code ](https://developers.redhat.com/articles/2022/01/05/extracting-information-python-source-code#) 从python源文件中检索导包信息

# Component-Based Architecture

[Component-Based Architecture](https://www.tutorialspoint.com/software_architecture_design/component_based_architecture.htm)

组件将软件元素的功能和行为封装到可重用和自部署的二进制单元中。

面向组件的软件设计具有很多优势：

+ 通过重用现有组件，缩短了上市时间和开发成本。  （节约时间、开发成本）
+ 通过重用现有组件提高了可靠性。

### 组件的定义

组件是一组模块化、便携式、可替换和可重用的清晰定义的功能集，可以封装其实现并将其导出为高级接口。

组件是一个软件对象，旨在与其他组件交互，封装某些功能或一组功能。它有一个明确定义的接口，并符合推荐的体系结构内所有组件通用的行为。

软件组件可以定义为具有合同规定的接口和显式上下文依赖关系的组合单元。也就是说，软件组件可以独立部署，并由第三方组成。

### 组件的特性

可重用性：组件通常被设计为在不同应用的不同情况下重复使用。然而，一些组件可能是为特定任务设计的。

可替换性：组份可以自由地用其他类似的组份替代。

没有特定的环境：组件设计为在不同的环境和上下文中运行。

可扩展性：组件可以从现有组件扩展以提供新的行为。

高度封装：组件描述允许调用者使用其功能的接口，并且不公开内部流程的细节或任何内部变量或状态。

独立的：组件被设计为对其他组件具有最小的依赖关系。

## 组件级设计指南

为指定为体系结构模型一部分的组件创建命名约定，然后作为组件级模型的一部分进行细化或细化。

+ 从问题域中获取体系结构组件名称，并确保它们对查看体系结构模型的所有涉众都有意义。
+ 提取可以独立存在而不依赖于其他实体的业务流程实体。
+ 将这些独立实体识别并发现为新组件。
+ 使用反映其实现特定含义的基础结构组件名称。
+ 从左到右建模任何依赖项，以及从上级（基类）到下级（派生类）的继承。
+ 将任何组件依赖项建模为接口，而不是将它们表示为直接的组件到组件依赖项。

## 组件化的好处

+ 易于部署− 随着新的兼容版本的推出，在不影响其他组件或整个系统的情况下，更容易替换现有版本。
+ 降低成本− 使用第三方组件可以分摊开发和维护成本。
+ 易于开发-组件实现众所周知的接口来提供定义的功能，允许开发而不会影响系统的其他部分。
+ 可重用−可重用组件的使用意味着它们可以用于跨多个应用程序或系统分摊开发和维护成本。
+ 技术复杂性修改− 组件通过使用组件容器及其服务来修改复杂性。
+ 可靠性-整体系统可靠性提高，因为每个组件的可靠性通过重用提高了整个系统的可靠性。
+ 系统维护和进化-易于更改和更新实现，而不会影响系统的其他部分。
+ 独立的− 组件的独立性和灵活连接。由不同组并行独立开发组件。软件开发和未来软件开发的生产力。

# 代码提取参考

[CCodeExtractor:一种针对 C 程序自动化的函数提取方法](http://staff.ustc.edu.cn/~yuzhang/papers/CCodeExtractor.pdf)

##  Retrieval on Source Code: A Neural Code Search

> 这篇文章主要是检索代码中的方法信息，做的是一个在源代码上检索有效代码的检索系统

在本文中，我们关注另一种开发人员生产力工具：代码搜索。开发人员经常搜索如何完成特定编码任务的示例。

主要是以方法或函数的粒度为一段代码创建一个自然语言“文档”。

### Extracting Information from Source Code

我们改为使用基于解析器的方法，在该方法中，我们遍历每个方法的解析树，并从以下语法类别中提取信息

方法名：提取方法名称，并将其与包含方法的类名一起使用。

方法调用：方法调用可以说是代码块中最重要的信息，因为它们给出了关于代码中正在发生的事情的提示。其他功能，如控制流，也很重要，但不容易用自然语言表达。

枚举：与局部变量不同，这些常量的命名非常谨慎，包含有关程序状态的有意义的信息。

字符串：它们通常包括面向人的文本和文档，两者都包含我们提取的有用单词。

注释：它们包含非常有用的信息，因为它们已经是代码的自然语言描述

#  An Application Software Analytics Toolkit for Facilitating the Understanding, Componentization, and Refactoring of Large-Scale Scientifific Models

这个新的工具包能够收集源代码信息，分析库依赖关系，揭示代码使用的特殊软硬件功能，以及识别特殊工具和特定编译器版本的需求。

**可以从软件X射线扫描仪中提取的信息如下所示：**

+ 软件的基本结构和功能以及它们之间的关系。
+ 第三方库组件和组成：显示在依存关系图中，每个都具有所需的最小版本号。
+ 编程语言：使用哪些特定语言及其最低语言版本。
+ 编译器：软件包需要哪些编译器和版本。
+ 计算机架构组件：软件包是否需要GPU、AVX、NUMA控制、FPGA、并行文件系统、突发缓冲区、NVLink、GPUDirect等。根据软件构建流程配置选项，我们将每个硬件组件分为三类：（i）授权，（ii）性能关键，或（iii）便携式但速度慢。
+ 通信层：软件包使用MPI库、RDMA、Socket或其他特殊通信库。
+ 编程模型识别：MPI、混合MPI/P线程/OpenMP、PGAS、AMT(异步多任务)或其他并行计算模型。