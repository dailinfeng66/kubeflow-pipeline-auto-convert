# AST转换结果文档

## 组件的定义标准

+ 一个py文件里面只能够存在两种代码，如果存在其他代码可能会引起代码转换错误

	+ 导包代码
	+ 方法代码

+ 方法定义语句上不需要写返回值类型eg: <code>->str/***</code> 这样写将导致编译出错

	✅正确方法定义写法：

	```python
	def fun1min(params, x, y):
	```

	❌错误方法定义写法：

	```python
	def fun1min(params, x, y)->str:
	```

+ 方法的返回语句不能够是一串表达式，应该写为变量返回的形式。如果写成了表达式的形式将导致代码转换错误 无法成功编译

	✅正确的返回方式

	```python
	res_model = model - y
	return res_model
	```

	❌错误的表达方式

	```python
	return model - y
	```

+ 一个方法内调用的方法如果不是安装的第三方包，那么这个方法只能在当前文件中，不能是在其他文件中，如果在其他文件中将导致找不到调用的方法，组件无法运行 

## 任务的背景及意义

### 背景

​		当非编程研究人员需要编程完成一定的研究任务时，学习编程将会花费一定的人力物力时间成本，如果设计出一个通过流程图、逻辑脚本就能完成程序编写的低代码平台，或者是无代码平台将能够大大减少成本。因此基于这一目的我们选择开发出这一平台。在平台的开发上，选择使用kubeflow的pipeline功能作为载体，在pipeline的基础上开发一套自动化流程，用户只需要绘制组件的调用流程图或者是写出组件的流程脚本即可。平台将解析脚本或者是流程图，将脚本或者是流程图转换成pipeline定义的代码，再运行代码生成kubeflow内的pipeline并运行。

​		研究人员在进行流程编排的前提是平台上有一定数量的计算组件可以被调用，因此集成足够多的组件是一项非常重要的问题。外部组件的集成就是一项重复性的工作。如果我们需要使得我们在kubeflow的pipeline功能上构建更多的pipeline和更加方便的构建pipeline我们就需要拥有足够多的组件。此时依靠我们手工的去集成组件效率将会变得非常低下。

​	基于以上问题我们可以开发出一套对普通python代码进行扫描的工具，此工具能够扫描python代码，并将python代码内的方法转换为pipeline 组件定义的规范代码，并运行此代码生成组件的yaml文件，最后将此yaml文件自动上传到组件统一管理中心。

 ### 意义

​		平台主要是将编程简化，能够更加快速构建出数据计算、数据处理和深度学习的pipeline的程序，简化开发流程、提高代码的复用率、提高开发效率、减少重复性的工作、提高研究效率。同时能够集中管理每条pipeline，对一个实验的所有pipeline也可以进行集中管理和对比，提高实验效率。

## 转换代码的重难点

​		转换代码的重难点是对AST的遍历，在遍历的同时会遍历到每一个节点，此时应该针对不同的节点做不同的处理，并且对遍历方式也有一定的要求，当前采用的是后序遍历，在后序遍历中扫描到方法以后会先处理方法内部的节点，最后再扫描方法定义节点本身，因此在扫描方法体的时候可以找出当前方法调用了哪些外部方法，在扫描方法定义节点的时候就可以将这些方法节点获取到并将这些被调用的方法节点添加到当前方法中。在整个代码的转换过程中，难点是return语句的处理，return语句在AST中是一个单独的节点，这个节点内的属性名和属性值根据return的不同而不同，没有统一的模式去匹配他，因此只能获取到返回代码的节点，将节点转换为返回代码，然后根据字符串去进行处理，因此需要满足一定的模式（只能返回变量，不能有除变量以外的其他返回方式）。

## 原来代码处理方式和现在代码处理方式的比较

#### 原来代码处理方式

​	处理方式：以字符串的方式按行扫描并按规则对代码进行匹配，根据不同的匹配类别处理代码

​	解决的问题：原来根据字符串处理代码的方式能够有效的对代码的方法定义语句、源文件中的导包语句、方法的返回语句进行识别、方法体等进行识别，并在一定的规范内对代码进行有效的转换。能够在代码转换成功之后存为.py文件并进行运行以获得编译好的yaml文件。

+ 优点：
	+ 根据字符串进行处理，处理方式简单快捷。根据字符串规则进行匹配，匹配方式简单。
	+ 可以直接使用java进行开发，并直接进行调用。
+ 局限性
	+ 开发过程中处理逻辑粘连性强、可维护性低、代码的可复用性低，部分代码逻辑复杂，健壮性不高。
	+ 遇到不同写法的代码的时候需要对该写法的代码进行适配，当代码写法种类较多的时候内部代码处理的逻辑就会变得难以维护。
	+ 采用正则表达式的形式虽快捷有效，但还是有很多代码写法无法被匹配到，存在一定的欠缺。

### 采用AST的方式处理代码

​		AST (Abstract Syntax Tree(抽象语法树)) 是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构。它由一堆节点（Node）组成，每个节点都表示源代码中的一种结构。

​		在python中，内置了ast包，能够将传入的代码生成AST，并且能够使用ast的内置api对AST进行遍历和处理，在python的ast包中提供了两个类对ast进行处理，分别是<code>class ast.NodeVisitor</code> 和 <code>class ast.NodeTransformer</code>这两个的区别就是visit是修改原来的node,transformer可以替换一个新的node。这两种类采用的对AST遍历的方式都是递归遍历，结合当前代码处理的需求，我最终选择了后序遍历，在遍历过程中对节点进行处理和替换，并选择使用<code>ast.NodeTransformer</code>类进行处理。

​		在使用ast之后，对代码种类的判断可以直接交给ast包内置的api来实现，我们只需要关注对不同种类的代码进行不同的处理即可，当实现了对应节点的visit方法以后便可以对指定的节点进行处理，每一个种类的节点都是一个实体类，对节点内的代码处理就是对实体类进行处理，并返回修改或者是新生成的实体类便可以便可以完成一个节点的替换。对抽象语法树上的每一种节点进行处理对应的是一个遍历类中不同的处理方法，其优点是能够将不同节点的处理逻辑分开来，提高代码的可维护性，提高程序的健壮性。代码可复用性强，粘连性低。并且不用特定的去匹配指定的语句，不同的语法结构有不同的节点来表示，对一种节点下的其他节点能够使用递归的方式遍历到，因此采用合适的递归方式就能够找出当前节点的所有子节点进行处理。

​		在ast包使用的过程中同时也发现了使用ast仍然不能很好解决的问题，在AST中，return返回代码的定义是一个Return节点，这个节点的value是return内表达式的节点，但是return可以返回很多种种类的值，不仅仅是变量，还可以是表达式或者是方法的调用等等，因此没办法使用ast对返回值进行处理。也因此采用了字符串的方式处理了这部分代码。

### 方法的生成过程

+ 读取源代码，将代码使用ast包转换成ast对象，并传入visit类进行遍历
+ 首先使用循环的方式遍历一遍源代码的所有顶层节点，将方法节点对应的方法名和方法节点类放到一个字典中以供后序调用。
+ 在ast.NodeTransformer实现类中添加不同节点的实现方法：visit_Import、visit_ImportFrom、visit_Return、visit_FunctionDef、visit_Call，不同的vist方法使用的是不同节点的访问方法。
+ 采用后序遍历的方式，首先遍历一个节点的所有子节点，获取到全局的导包语句、当前方法节点的子节点中的其他方法调用节点。将全局的导包语句都存储到list中，将调用其他方法节点获取到之后获取被调用方法的方法名。
+ 大多数的逻辑写在visit_FunctionDef方法中，这是方法定义节点的处理方法，这个方法会在当前方法节点所有子节点visit之后调用，首先遍历方法的参数节点，将参数节点的参数名和参数类型进行重新处理，添加返回参数元数据形参，并替换掉原来的形参节点。
+ 在方法体的下一行添加导包语句节点，体现在代码上就是在方法定义语句的下一行添加导包语句
+ 添加完导包语句之后添加当前方法所调用方法的方法节点。获取到存储的方法节点，获取到方法节点之后添加到导包节点之后
+ 添加调用方法节点之后添加原有形参还原的代码节点。获取到原有形参名，使用字符串拼接的方式拼接出从元数据中加载数据的代码，并使用ast包转换为AST节点，并将节点添加到方法定义语句之后
+ 获取到Return节点，将return节点还原为字符串形式的代码，使用字符串的形式进行返回元数据的封装和逻辑代码的生成，生成之后使用ast包封装为node节点并替换原有的return节点。
+ 使用字符串的形式生成组件装饰器代码，并使用ast包转换为装饰器节点添加到方法节点的指定属性上。
+ 将修改好的ast转换为代码，并将代码写入python文件中。

在使用ast对代码进行处理之后，我们能够更加快捷方便的对整个代码进行处理，能够使用一定的结构方法去操作代码块，同时能够处理整个项目中的代码，而非局限于一个.py文件内的代码，对代码的处理消除了想不到的书写模式。能够精确的定位到方法代码中对其他方法的调用等。使得代码更加的规范，兼容性更强。
