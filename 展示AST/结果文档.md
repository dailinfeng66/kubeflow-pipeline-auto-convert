# AST转换结果文档

## 任务的背景及意义

### 背景

​		当非编程研究人员需要编程完成一定的研究任务时，学习编程将会花费一定的人力物力时间成本，如果设计出一个通过流程图、逻辑脚本就能完成程序编写的低代码平台，或者是无代码平台将能够大大减少成本。因此基于这一目的我们选择开发出这一平台。在平台的开发上，选择使用kubeflow的pipeline功能作为载体，在pipeline的基础上开发一套自动化流程，用户只需要绘制组件的调用流程图或者是写出组件的流程脚本即可。平台将解析脚本或者是流程图，将脚本或者是流程图转换成pipeline定义的代码，再运行代码生成kubeflow内的pipeline并运行。

​		研究人员在进行流程编排的前提是平台上有一定数量的计算组件可以被调用，因此集成足够多的组件是一项非常重要的问题。外部组件的集成就是一项重复性的工作。如果我们需要使得我们在kubeflow的pipeline功能上构建更多的pipeline和更加方便的构建pipeline我们就需要拥有足够多的组件。此时依靠我们手工的去集成组件效率将会变得非常低下。

​	基于以上问题我们可以开发出一套对普通python代码进行扫描的工具，此工具能够扫描python代码，并将python代码内的方法转换为pipeline 组件定义的规范代码，并运行此代码生成组件的yaml文件，最后将此yaml文件自动上传到组件统一管理中心。

 ### 意义

​		平台主要是将编程简化，能够更加快速构建出数据计算、数据处理和深度学习的pipeline的程序，简化开发流程、提高代码的复用率、提高开发效率、减少重复性的工作、提高研究效率。同时能够集中管理每条pipeline，对一个实验的所有pipeline也可以进行集中管理和对比，提高实验效率。

## 转换代码的重难点

​		转换代码的重难点是对AST的遍历，在遍历的同时会遍历到每一个节点，此时应该针对不同的节点做不同的处理，并且对遍历方式也有一定的要求，当前采用的是后序遍历，在后序遍历中扫描到方法以后会先处理方法内部的节点，最后再扫描方法定义节点本身，因此在扫描方法体的时候可以找出当前方法调用了哪些外部方法，在扫描方法定义节点的时候就可以将这些方法节点获取到并将这些被调用的方法节点添加到当前方法中。在整个代码的转换过程中，难点是return语句的处理，return语句在AST中是一个单独的节点，这个节点内的属性名和属性值根据return的不同而不同，没有统一的模式去匹配他，因此只能获取到返回代码的节点，将节点转换为返回代码，然后根据字符串去进行处理，因此需要满足一定的模式（只能返回变量，不能有除变量以外的其他返回方式）。



## 组件的定义规则和写法

### 组件定义方法中正确的写法

+ 一个py文件里面只能够存在两种代码，如果存在其他代码可能会引起代码转换错误

	+ 导包代码
	+ 1方法代码

+ 不能够在方法内部去定义方法

+ 方法定义语句上不需要写返回值类型eg: <code>->str/***</code> 这样写将导致编译出错

	✅正确方法定义写法：

	```python
	def fun1min(params, x, y):
	```

	❌错误方法定义写法：

	```python
	def fun1min(params, x, y)->str:
	```

+ 方法的返回语句不能够是一串表达式，应该写为变量返回的形式。如果写成了表达式的形式将导致代码转换错误 无法成功编译

  ✅正确的返回方式

  ```python
  res_model = model - y
  return res_model
  ```

  ❌错误的表达方式

  ```python
  return model - y
  ```

  ### 组件定义过程中正确的规则

  正确的方法代码如下图所示，这样的方法代码将能够直接被转换为组件代码。

```python
import requests
import numpy as np
import pandas as pd


# 方法的定义语句，定义方法声明参数，参数可以是变量名
def load_data(url, filename: str, url1: int = 10):
    f = requests.get(url)
    with open(filename, 'wb') as code:
        code.write(f.content)
    a = pd.read_excel(filename)
    xdata = a[['t', 'X_t_1', 'X_t_2', 't_T_1_X_t_1', 't_T_2_X_t_2', 'H_t', 'ck1', 'sk1', 'ck2', 'sk2']]
    ydata = np.log(a["Y"])
    #  方法的返回结果，只能够是返回一个或多个变量的形式
    return xdata, ydata
```

脚本转换完成之后的代码如下所示：

```python
# 脚本添加的导的kubeflow pipeline SDK需要导入的包
import kfp
from kfp.v2 import dsl
from kfp.v2.dsl import component, Input, Output, OutputPath, Dataset, Model,InputPath
import kfp.components as comp

import requests
import numpy as np
import pandas as pd
# 生成的组件添加组件标识的装饰器，装饰器第一个参数是将此方法转换为组件yaml代码的文件名 第二个参数是当前组件需要用到的第三方包
@component(output_component_file='load_data_component.yaml', packages_to_install=['joblib', 'requests', 'numpy', 'pandas'])
# 组件方法定义   将原有方法的形参转换为输入元数据的形参并指定元数据类型为Input[Dataset]  并在形参上添加输出数据的元数据
def load_data(url_input:Input[Dataset], filename_input:Input[Dataset], url1_input:Input[Dataset], load_data_output:Output[Dataset]):
#     脚本扫描到当前组件所在源代码中引用的第三方包，然后将这些第三方包添加到组件方法内（因为组件方法外的包在组件打包的时候扫描不到）
    import requests
    import numpy as np
    import pandas as pd
    import joblib

    url = joblib.load(url_input.path)['url']
    filename = joblib.load(filename_input.path)['filename']
    url1 = joblib.load(url1_input.path)['url1']
    f = requests.get(url)
    with open(filename, 'wb') as code:
        code.write(f.content)
    a = pd.read_excel(filename)
    xdata = a[['t', 'X_t_1', 'X_t_2', 't_T_1_X_t_1', 't_T_2_X_t_2', 'H_t', 'ck1', 'sk1', 'ck2', 'sk2']]
    ydata = np.log(a['Y'])
#     将组件的返回参数转化为字典的方式并落地到输出元数据指向的地方
    return joblib.dump({'xdata': xdata, ' ydata': ydata}, load_data_output.path)
```



## 代码处理方式及比较

将一般的方法代码处理为组件代码有两种方法，第一种方法是使用字符串的方式进行转换，将源代码文件以字符串的方式读取，再以行为单位进行处理。第二种方法是使用python的ast包，将代码转换成抽象语法树，再对抽象语法树中的代码节点进行相应的替换即可。下面将对两种代码转换方式进行介绍。

#### 以一行代码的字符串处理方式

​	处理方式：将源文件以字符串的方式取出，再以行为单位对代码进行遍历和处理，当遍历到某一行之后将使用特定的规则或者是使用正则表达式的形式去匹配含有指定语法的代码，并进行不同的处理。

​	解决的问题：原来根据字符串处理代码的方式能够有效的对代码的方法定义语句、源文件中的导包语句、方法的返回语句进行识别、方法体等进行识别，并在一定的规范内对代码进行有效的转换。能够在代码转换成功之后存为.py文件并进行运行以获得编译好的yaml文件。

+ 优点：
	+ 根据字符串进行处理，处理方式简单快捷。根据字符串规则进行匹配，匹配方式简单。
	+ 可以直接使用java进行开发，并直接进行调用。
	+ 上手快、逻辑简单。
+ 局限性
	+ 开发过程中处理逻辑粘连性强、可维护性低、代码的可复用性低，部分代码逻辑复杂，健壮性不高。
	+ 遇到不同写法的代码的时候需要对该写法的代码进行适配，当代码写法种类较多的时候内部代码处理的逻辑就会变得难以维护。
	+ 采用正则表达式的形式虽快捷有效，但还是有很多代码写法无法被匹配到，存在一定的欠缺。
	+ 对整个项目，多源文件的python项目的支持较差，并且开发难度较高。

### 代码生成过程

+ 匹配到方法的导包语句，并添加joblib包
+ 在源文件顶部添加pipeline SDK的导包语句
+ 扫描所有的方法，将所有的方法代码保存到map中以便后序方法调用代码转换
+ 通过正则匹配到方法定义代码，将方法定义代码中形参进行转换，并添加上输出元数据的形参
+ 生成当前方法定义代码的装饰器代码，并将装饰器代码添加到方法定义代码的上一行
+ 将导包语句添加到方法定义代码的下一行
+ 扫描整个方法的代码，获取到方法调用的代码，将被调用的方法代码添加到当前方法体中，并放到导包语句下
+ 将方法原有形参通过加载元数据的方式进行还原
+ 扫描到方法返回代码，将方法返回代码修改为落地到元数据指向位置的代码

### 采用AST的方式处理代码

​		AST (Abstract Syntax Tree(抽象语法树)) 是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构。它由一堆节点（Node）组成，每个节点都表示源代码中的一种结构。

​		在python中，内置了ast包，能够将传入的代码生成AST，并且能够使用ast的内置api对AST进行遍历和处理，在python的ast包中提供了两个类对ast进行处理，分别是<code>class ast.NodeVisitor</code> 和 <code>class ast.NodeTransformer</code>这两个的区别就是visit是修改原来的node,transformer可以替换一个新的node。这两种类采用的对AST遍历的方式都是递归遍历，结合当前代码处理的需求，我最终选择了后序遍历，在遍历过程中对节点进行处理和替换，并选择使用<code>ast.NodeTransformer</code>类进行处理。

​		在使用ast之后，对代码种类的判断可以直接交给ast包内置的api来实现，我们只需要关注对不同种类的代码进行不同的处理即可，当实现了对应节点的visit方法以后便可以对指定的节点进行处理，每一个种类的节点都是一个实体类，对节点内的代码处理就是对实体类进行处理，并返回修改或者是新生成的实体类便可以便可以完成一个节点的替换。对抽象语法树上的每一种节点进行处理对应的是一个遍历类中不同的处理方法，其优点是能够将不同节点的处理逻辑分开来，提高代码的可维护性，提高程序的健壮性。代码可复用性强，粘连性低。并且不用特定的去匹配指定的语句，不同的语法结构有不同的节点来表示，对一种节点下的其他节点能够使用递归的方式遍历到，因此采用合适的递归方式就能够找出当前节点的所有子节点进行处理。

​		在ast包使用的过程中同时也发现了使用ast仍然不能很好解决的问题，在AST中，return返回代码的定义是一个Return节点，这个节点的value是return内表达式的节点，但是return可以返回很多种种类的值，不仅仅是变量，还可以是表达式或者是方法的调用等等，因此没办法使用ast对返回值进行处理。也因此采用了字符串的方式处理了这部分代码。

### 方法的生成过程

+ 读取源代码，将代码使用ast包转换成ast对象，并传入visit类进行遍历
+ 首先使用循环的方式遍历一遍源代码的所有顶层节点，将方法节点对应的方法名和方法节点类放到一个字典中以供后序调用。
+ 添加visit_ClassDef扫描类定义，将类定义的代码添加到字典中。
+ 在ast.NodeTransformer实现类中添加不同节点的实现方法：visit_Import、visit_ImportFrom、visit_Return、visit_FunctionDef、visit_Call，不同的vist方法使用的是不同节点的访问方法。
+ 采用后序遍历的方式，首先遍历一个节点的所有子节点，获取到全局的导包语句、当前方法节点的子节点中的其他方法调用节点。将全局的导包语句都存储到list中，将调用其他方法节点获取到之后获取被调用方法的方法名。
+ 大多数的逻辑写在visit_FunctionDef方法中，这是方法定义节点的处理方法，这个方法会在当前方法节点所有子节点visit之后调用，首先遍历方法的参数节点，将参数节点的参数名和参数类型进行重新处理，添加返回参数元数据形参，并替换掉原来的形参节点。
+ 在方法体的下一行添加导包语句节点，体现在代码上就是在方法定义语句的下一行添加导包语句
+ 添加完导包语句之后添加当前方法所调用方法的方法节点。获取到存储的方法节点，获取到方法节点之后添加到导包节点之后。扫描方法节点的同时扫描类的初始化调用节点，如果有的话就将类代码添加到导包节点之后
+ 添加调用方法节点之后添加原有形参还原的代码节点。获取到原有形参名，使用字符串拼接的方式拼接出从元数据中加载数据的代码，并使用ast包转换为AST节点，并将节点添加到方法定义语句之后
+ 获取到Return节点，将return节点还原为字符串形式的代码，使用字符串的形式进行返回元数据的封装和逻辑代码的生成，生成之后使用ast包封装为node节点并替换原有的return节点。
+ 使用字符串的形式生成组件装饰器代码，并使用ast包转换为装饰器节点添加到方法节点的指定属性上。
+ 将修改好的ast转换为代码，并将代码写入python文件中。

在使用ast对代码进行处理之后，我们能够更加快捷方便的对整个代码进行处理，能够使用一定的结构方法去操作代码块，同时能够处理整个项目中的代码，而非局限于一个.py文件内的代码，对代码的处理消除了想不到的书写模式。能够精确的定位到方法代码中对其他方法的调用等。使得代码更加的规范，兼容性更强。

+ 优点
	+ 处理逻辑简单，逻辑清晰
	+ 能够处理一个python工程的代码
	+ 开发出来的程序健壮性高，可维护性好。
	+ 能够匹配到类的使用并将类的使用也添加到方法调用代码中
+ 局限性
	+ 仍存在ast不能解决的节点，此类节点需要将ast节点转化为字符串的方式进行处理。
	+ 存在一定的学习成本

## 整体方法目前还存在的不足

+ 暂时没有完成整个python项目的扫描

	
