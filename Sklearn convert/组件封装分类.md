# 组件的封装和分类

当前能够封装的组件主要是以数据为传输介质的方法，其中数据指的是数据的值而不是数据的引用，当我们需要一个方法对数据进行处理的时候只需要将当前的数据输入组件并获取组件处理之后的输出。如果方法中含有对数据的引用，或者是对公共变量的修改则此类方法并不合适封装称为一个具体的组件。

| 组件类别                                               | 是否能够封装为组件 | 原因                                                         |
| ------------------------------------------------------ | ------------------ | ------------------------------------------------------------ |
| 无数据输入有输出                                       | ✅                  | 这种组件只需要返回数据，属于常规类型                         |
| 有数据值的输入和输出                                   | ✅                  | 这种组件输入值，将该值进行计算之后将值输出，属于常规组件     |
| 在方法内调用了其他组件的方法                           | ❌                  | 不能够在组件内调用其他组件                                   |
| 有循环条件，循环调用的组件                             | ☑️                  | 理论上大部分都能够使用parallelfor执行，目前parallelfor没有调通 |
| 有if判断的                                             | ✅                  | 能够根据dsl.Condition 来进行if转换                           |
| 对外部变量有依赖，多个方法修改一个外部变量作为信号量的 | ❌                  | 组件在运行的时候是独立的，不能使用一个外部变量作为信号量     |
| 外部变量是以引用的方式传入参数的方法                   | ❌                  | 组件都是以数据输入，数据处理，数据输出为操作步骤的。每个组件都是独立运行在docker容器中的。因此不能够处理引用的方式 |
|                                                        |                    |                                                              |



适合官方for的情况：

每一趟for都是互相独立的，不能够出现收集for 结果的情况存在->for循环每一趟的结果都添加到一个list里面。



